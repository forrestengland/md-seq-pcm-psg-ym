#ifndef H_SAVEGAME
#define H_SAVEGAME

/* savegame stuff */
// Define key SRAM memory addresses as volatile pointers
// Volatile is crucial as the hardware might change values outside the C program's control
// used to save the sequence
#define SRAM_START_ADDR ((volatile uint8_t*)0x200001)
#define SRAM_END_ADDR ((volatile uint8_t*)0x20FFFF)
#define SRAM_LOCK_ADDR  ((volatile uint8_t*)0xA130F1)

// Define a simple structure for game save data
typedef struct {
  uint16_t magic;

  uint8_t tempo;
  uint8_t ym_attack;
  uint8_t ym_lfo_enable;
  uint8_t ym_lfo_speed;
  uint8_t ym_detune;
  uint8_t ym_mult;
  uint8_t ym_level;
  uint8_t ym_release;
  uint8_t ym_sustain;
  uint8_t ym_decay;
  uint8_t ym_am;
  
  uint8_t sequence[16];
  uint8_t accent[16];
  uint8_t speed[16];
  uint8_t psgnote[16];
  int8_t ymNoteCh0[16];
  
  uint8_t  checksum;      // Simple checksum for data integrity - (ignored here)
  uint8_t  padding;       // Padding to ensure alignment if needed, although 8-bit access is standard
  
} GameSaveData;

GameSaveData mySave; // our data to save/load

void save_game_to_sram(const GameSaveData* data);
uint8_t load_game_from_sram(GameSaveData* data);
uint8_t calculate_checksum(const GameSaveData* data);
void unlock_sram(void);
void lock_sram(void);

void unlock_sram(void) {
    // Write 1 to the SRAM lock address to enable writing
    *SRAM_LOCK_ADDR = 1;
}

void lock_sram(void) {
    // Write 0 to the SRAM lock address to disable writing
    *SRAM_LOCK_ADDR = 0;
}

uint8_t calculate_checksum(const GameSaveData* data) {
    uint8_t sum = 0;
    const uint8_t* byte_ptr = (const uint8_t*)data;
    // Iterate over all bytes except the checksum itself (last byte before padding)
    for (long unsigned int i = 0; i < sizeof(GameSaveData) - sizeof(uint8_t); i++) {
        sum += byte_ptr[i];
    }
    return sum;
}

void save_game_to_sram(const GameSaveData* data) {
    // In bare-metal C, you need to disable interrupts before accessing memory-mapped I/O
    // This is system-specific, usually involving assembly code or specific CPU registers.
    // Assuming you have a function `disable_interrupts()` and `enable_interrupts()`

    // disable_interrupts(); 
    unlock_sram();

    // The Sega Genesis uses an odd 8-bit addressing scheme for SRAM
    // This means we must write to every *other* physical address.
    // In C, we can iterate over our structure byte by byte and manually
    // write to the correct addresses, offsetting by 2 bytes in memory for each logical byte of data.

    const uint8_t* src = (const uint8_t*)data;
    volatile uint8_t* dest = SRAM_START_ADDR;
    
    for (long unsigned int i = 0; i < sizeof(GameSaveData); i++) {
        // Write the byte from the source structure to the SRAM destination
        *dest = src[i];
        // Move to the next valid SRAM address (skip the next byte)
        dest += 2; 
    }

    lock_sram();
    // enable_interrupts(); 
}

uint8_t load_game_from_sram(GameSaveData* data) {
    // disable_interrupts(); // Disable interrupts

    const volatile uint8_t* src = SRAM_START_ADDR;
    uint8_t* dest = (uint8_t*)data;

    for (long unsigned int i = 0; i < sizeof(GameSaveData); i++) {
        // Read the byte from the SRAM source
        dest[i] = *src;
        // Move to the next valid SRAM address (skip the next byte)
        src += 2;
    }

    // enable_interrupts(); // Re-enable interrupts

    // Verify data integrity using the magic number and checksum
    if (data->magic != 0xABCE) { // Check if the save data has been initialized
	vdp_text_clear(VDP_PLAN_A, 3, 18, 40);
	vdp_puts(VDP_PLAN_A, "incorrect magic", 3, 18);
        return 0; 
    }
    if (data->checksum != calculate_checksum(data)) { // Check if data is corrupted
	vdp_text_clear(VDP_PLAN_A, 3, 18, 40);
	vdp_puts(VDP_PLAN_A, "checksum mismatch", 3, 18);
//        return 0;
	return 1;
    }

    return 1; // Success
}

void savegame_init(void) {

    // Try to load data first
    if (load_game_from_sram(&mySave)) {
        // Data loaded successfully, continue game
        // ... use mySave.player_score, etc.
      tempo = mySave.tempo;
      ym_attack = mySave.ym_attack;
      ym_lfo_enable = mySave.ym_lfo_enable;
      ym_lfo_speed = mySave.ym_lfo_speed;
      ym_detune = mySave.ym_detune;
      ym_mult = mySave.ym_mult;
      ym_level = mySave.ym_level;
      ym_release = mySave.ym_release;
      ym_sustain = mySave.ym_sustain;
      ym_decay = mySave.ym_decay;
      ym_am = mySave.ym_am;
      
      for (int i=0; i<16; i++) {
	gateseq[i] = mySave.sequence[i];
	accseq[i] = mySave.accent[i];
	speedseq[i] = mySave.speed[i];
	psgNoteSeq[i] = mySave.psgnote[i];
	ymNoteSeq[i] = mySave.ymNoteCh0[i];
      }

      // send the saved settings to the ym chip
      set_ym_lfo(ym_lfo_enable, ym_lfo_speed);
      set_ym_detune_mult(ym_detune, ym_mult);
      set_ym_level(ym_level);
      set_ym_attack(ym_attack);
      set_ym_release_sustain(ym_release, ym_sustain);
      set_ym_decay_am(ym_decay, ym_am);
      
      vdp_text_clear(VDP_PLAN_A, 3, 18, 40);
      vdp_puts(VDP_PLAN_A, "saved sequence loaded", 3, 18);
    } else {
        // No valid save data found, start a new game and initialize structure
        mySave.magic = 0xABCE; // Set magic number

	mySave.tempo = tempo;
	mySave.ym_attack = ym_attack;
	mySave.ym_lfo_enable = ym_lfo_enable;
	mySave.ym_lfo_speed = ym_lfo_speed;
	mySave.ym_detune = ym_detune;
	mySave.ym_mult = ym_mult;
	mySave.ym_level = ym_level;
	mySave.ym_release = ym_release;
	mySave.ym_sustain = ym_sustain;
	mySave.ym_decay = ym_decay;
	mySave.ym_am = ym_am;
	
	for (int i=0; i<16; i++) {
	  mySave.sequence[i] = gateseq[i];
	  mySave.sequence[i] = accseq[i];
	  mySave.speed[i] = speedseq[i];
	  mySave.psgnote[i] = psgNoteSeq[i];
	  mySave.ymNoteCh0[i] = ymNoteSeq[i];	  
	}
	
        // Calculate and set initial checksum
        mySave.checksum = calculate_checksum(&mySave); 
        // Save the initial data to SRAM immediately
        save_game_to_sram(&mySave);
    }
}

void savegame() {

  mySave.tempo = tempo;
  mySave.ym_attack = ym_attack;
  mySave.ym_lfo_enable = ym_lfo_enable;
  mySave.ym_lfo_speed = ym_lfo_speed;
  mySave.ym_detune = ym_detune;
  mySave.ym_mult = ym_mult;
  mySave.ym_level = ym_level;
  mySave.ym_release = ym_release;
  mySave.ym_sustain = ym_sustain;
  mySave.ym_decay = ym_decay;
  mySave.ym_am = ym_am;

  for (int i=0; i<16; i++) {
    mySave.sequence[i] = gateseq[i];
    mySave.accent[i] = accseq[i];
    mySave.speed[i] = speedseq[i];
    mySave.psgnote[i] = psgNoteSeq[i];
    mySave.ymNoteCh0[i] = ymNoteSeq[i];    
  }
  
  mySave.checksum = calculate_checksum(&mySave); // Update checksum before saving
  save_game_to_sram(&mySave);
  vdp_text_clear(VDP_PLAN_A, 3, 18, 40);
  vdp_puts(VDP_PLAN_A, "sequence saved", 3, 18);
}

#endif
